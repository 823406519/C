# 派生数据类型与字符串
[toc]

## 数组类型
> 数组是容纳数量固定的单一类型值的数据结构（面向对象编程描述为对象，而不是数据结构)。数组创建后，数组大小就固定了。数组的元素访问使用数字下标（index），数组下标从0开始计数。

1. 数组声明

        type arrayName[arrayLength]
1. 数组声明与初始化
    * 使用字面量初始化：
    
        type arrayName[arrayLength]={value1, value2, ...}

    * 使用循环语句初始化，例如对int arrayName[arrayLength]初始化举例

            for(int i=0;i<arrayLength;i++){
                scanf("%d", &arrayName[i]);
            }    
1. 数组访问: `arrayName[index]`
1. 常量数组常量数组声明：`const type arrayName[arrayLength]`
1. 多维数组多维数组声明：`type arrayName[size][size]...[size]`
1. 多维数组的地址表示
   
        &arrayName[0]=arrayName;
        &arrayName[1]=arrayName+1;
        &arrayName[0][0]=arrayName[0];
        &arrayName[1][2]=arrayName[1]+2=*(arrayName+1)+2
1. 使用指针访问多维数组
使用指针访问多维数组，需要知道它的地址，使用*可以获得地址指向的值。
举例，要取值arrayName[m][n]...[p][q]
   
   > * 第一步需要知道它的地址
   &arrayName[m][n]...[p][q]=arrayName[m][n]...[p]+q=\*(arrayName[m][n]...+p)+q=...
   ><br>
   > * 对地址使用\*取值
   \*(arrayName[m][n]...[p]+q)=\*(\*(arrayName[m][n]...+p)+q)=...

1. 函数多维数组参数的声明需要指定最后一个[]的大小
        
        returnType functionName(type arrayName[][size],...);
        returnType functionName(type *arrayName[size],...);

## 指针类型
>指针（pointer），用来存储地址的变量，即指针存储地址值。
1. 指针声明与初始化
    * 指针声明
    `type pointerName`
    * 指针初始化
    `type pointerName=address`
    * **不要使用未初始化的指针**

2. 地址运算符与取值运算符
    * 地址运算符: **`&`**
    地址运算符可以取得变量的地址
    * 取值运算符: **`*`**
    取值运算符可以取指针指向地址的值, `*`是间接取值
    * 对于普通变量，直接值是它的普通变量值;间接值是地址，可以用&取得;对于指针变量，基本值是地址;间接值是地址指向的普通变量的值,用\*取得

3. 指针在函数参数中的作用
    **在函数调用中，如果形参是指针变量，那么实参我们可以传递一个地址，在函数中可以使用形参配合取值运算符(\*)改变形参的间接值，退出函数后，地址的间接值的改变也会被保存下来。**

4. 指针运算
    * 指针+n
    指针的地址移动n个指针类型的存储单位
    * 两个指针变量相减，得到地址距离

5. 常量指针与指针常量
    * 常量指针表示指针是一个指向常量的指针，常量指针限定了我们不能通过指针修改指针存储地址所指向的值。
    常量指针声明格式：`const type *pointerVariableName`
    * 指针常量，即指针是一个常量
    指针常量声明格式：`type  * const pointerVariableName`

6. 指针规范
    * 不同类型指针不可以相互赋值
    * 因为常量指针限定了修改指针指向的值。所以非常量指针可以赋值给常量指针。常量指针不能赋值给非常量指针。
    * 非常量指针的地址不能赋值给常量指针的指针

            cosnt int **p1;
            const int n;
            int *p2;
            p1=&p2 //假设可以
            *p1=&n
            *p2=10;//修改了常量值,所以不允许

## 结构类型
> 结构是可以存储多个不同数据类型数据的数据类型
1. 结构定义

        struct [structure tag]{
        //结构体成员定义
            member definition;
            member definition;
            ...
        }[one or more structure variable];

        /*
        structure tag是可选的项，一般首字母以大写命名。
        member definition是正常的变量定义。
        在结构定义的末尾，分号前，可以定义一个或者多个结构体变量，这也是可选项
        */
    结构定义举例

            struct Books{
                int bookId[10];
                char title[20];
                char author[20];
            }book;

2. 结构变量声明

        struct StructTagName structVariableName

3. 访问结构成员

        structVariableName.structMemberName

        //使用成员访问运算符(access member operator) . 访问结构成员。

4. 指向结构的变量定义和使用指向结构的变量访问结构成员
指向结构的变量定义

        struct StructTagName structVariableName;
        strct StructTagName *structPointer=&structVariableName;
        
    使用指向结构的变量访问结构成员
        
        strectPointer->strectMemberName

## 联合类型
> 联合,在同一个内存位置存储不同数据类型的特殊的数据类型

1. 联合定义

        union [union tag]{
            member definition;
            member definition;
            ...
        }[one or more union variables];

        /*
        union tag 是可选的，一般首字母大写命名。
        member difinition是普通的变量定义。
        在结构定义的尾部，;号前，可以定义一个或多个结构变量，这也是可选的
        联合会分配足够大的内存区容纳最大的结构成员。
        */

2. 联合变量声明

        union UnionTagName unionVariableName

1. 访问联合成员

        unionVariableName.unionMemberName

        //使用.(member access operator)运算符访问联合成员

# 字符串
> 字符串(string)是有一个或多个字符组成的, 以空字符 **'\0'** 结尾的一种数据类型（**空字符ASCII码是0**）。C并不将字符串(string) 作为一种数据类型。C中，以**一维字符数组**表示字符串。

1. 字符串的声明

        char string[length];

2. 字符串声明并初始化

        char string[]=literal | variable;
        char string2[]=literal | variable;

        // 字符串的字面量以 " " 环绕
        // 声明并初始化字符数组，可以不指定长度，长度会自动计算
